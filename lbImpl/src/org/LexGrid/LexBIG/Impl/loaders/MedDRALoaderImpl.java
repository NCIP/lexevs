package org.LexGrid.LexBIG.Impl.loaders;import java.net.URI;import java.util.List;import org.LexGrid.LexBIG.DataModel.InterfaceElements.ExtensionDescription;import org.LexGrid.LexBIG.Exceptions.LBInvocationException;import org.LexGrid.LexBIG.Exceptions.LBParameterException;import org.LexGrid.LexBIG.Extensions.Load.MedDRA_Loader;import org.LexGrid.LexBIG.Extensions.Load.OntologyFormat;import org.LexGrid.LexBIG.Extensions.Load.options.OptionHolder;import org.LexGrid.LexBIG.Utility.logging.LgMessageDirectorIF;import org.LexGrid.codingSchemes.CodingScheme;import org.lexevs.logging.messaging.impl.CachingMessageDirectorImpl;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.MedDRA2LGMain;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.MedDRAFormatValidator;import edu.mayo.informatics.lexgrid.convert.options.URIOption;import edu.mayo.informatics.lexgrid.convert.utility.URNVersionPair;public class MedDRALoaderImpl extends BaseLoader implements MedDRA_Loader {    private static final long serialVersionUID = 8418561158634673381L;    private URI UMLSCUISource;    public static String UMLSCUI_FILE_OPTION = "MRCONSO File";    OptionHolder options;    public MedDRALoaderImpl() {        super();        this.setDoApplyPostLoadManifest(false);    }    @Override    public String getMedDRAVersion() {        return "1.0";    }    @Override    protected ExtensionDescription buildExtensionDescription(){        ExtensionDescription temp = new ExtensionDescription();        temp.setExtensionBaseClass(MedDRALoaderImpl.class.getInterfaces()[0].getName());        temp.setExtensionClass(MedDRALoaderImpl.class.getName());        temp.setDescription(description);        temp.setName(name);        temp.setVersion( getMedDRAVersion() );        return temp;    }    @Override    public void validate(URI sourceDir, int validationLevel) throws LBParameterException {        String message;        try {            setInUse();            if (!MedDRAFormatValidator.isValidDirectory(sourceDir)) {                                throw new LBParameterException("The MedDRA directory is not valid:  " + sourceDir);            }                        List<String> missingFiles = MedDRAFormatValidator.allMedDRAfilesExist(sourceDir);            if (missingFiles.size() > 0) {                message = "Following MedDRA files are missing: \n";                for(int i=0; i < missingFiles.size(); i++){                    message += message + missingFiles.get(i) + "\n";                }                throw new LBParameterException(message);            }                        List<String> invalidFiles = MedDRAFormatValidator.allMedDRAfilesNotEmpty(sourceDir);             if (invalidFiles.size() > 0) {                message = "Following MedDRA files have invalid data: \n";                for(int i=0; i < invalidFiles.size(); i++){                    message += message + invalidFiles.get(i) + "\n";                }                throw new LBParameterException(message);            }        } catch (Exception e) {            throw new LBParameterException(e.getMessage());        } finally {            inUse = false;        }    }    @Override    public void load(URI uri, URI cuiUri, boolean stopOnErrors, boolean async) throws LBParameterException,            LBInvocationException {        this.getOptions().getBooleanOption(FAIL_ON_ERROR_OPTION).setOptionValue(stopOnErrors);        this.getOptions().getBooleanOption(ASYNC_OPTION).setOptionValue(async);        this.getOptions().getURIOption(UMLSCUI_FILE_OPTION).setOptionValue(cuiUri);        UMLSCUISource = cuiUri;        this.load(uri);    }    @Override    protected OptionHolder declareAllowedOptions(OptionHolder holder) {        holder.setIsResourceUriFolder(true);        holder.getURIOptions().add(new URIOption(UMLSCUI_FILE_OPTION));        return holder;    }                @Override    protected URNVersionPair[] doLoad() throws Exception{        LgMessageDirectorIF messages = new CachingMessageDirectorImpl(this.getMessageDirector());        MedDRA2LGMain mainTxfm = new MedDRA2LGMain();        //Set the source for the CUI file when using the GUI        if(UMLSCUISource == null){            UMLSCUISource = this.getOptions().getURIOption(UMLSCUI_FILE_OPTION).getOptionValue();        }        CodingScheme codingScheme = mainTxfm.map(UMLSCUISource, this.getResourceUri(), this.getMessageDirector());          if(codingScheme != null){            messages.info("Completed mapping.  Now saving to database");            this.persistCodingSchemeToDatabase(codingScheme);            messages.info("Saved to database.  Now constructing version pairs");                        return this.constructVersionPairsFromCodingSchemes(codingScheme);        }              //            this.buildRootNode(//                    Constructors.createAbsoluteCodingSchemeVersionReference(//                    codingScheme.getCodingSchemeURI(), codingScheme.getRepresentsVersion()), //                    Arrays.asList(MedDRA2LGConstants.ASSOCIATION_HAS_SUBTYPE), //                    getRelationsContainerName(codingScheme), //                    RootOrTail.ROOT,//                    TraverseAssociations.INDIVIDUALLY);                     return null;       }    //    private String getRelationsContainerName(CodingScheme codingScheme) {//        Relations[] relations = codingScheme.getRelations();//        Assert.state(relations.length == 1);//        //        return relations[0].getContainerName();//    }        @Override    public OntologyFormat getOntologyFormat() {        return OntologyFormat.MEDDRA;    }    public void finalize() throws Throwable {        getLogger().loadLogDebug("Freeing MedDRALoaderImpl");        super.finalize();    }    }