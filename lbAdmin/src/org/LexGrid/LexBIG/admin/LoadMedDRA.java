package org.LexGrid.LexBIG.admin;import java.net.URI;import org.LexGrid.LexBIG.DataModel.Core.AbsoluteCodingSchemeVersionReference;import org.LexGrid.LexBIG.Exceptions.LBResourceUnavailableException;import org.LexGrid.LexBIG.Extensions.Load.MedDRA_Loader;import org.LexGrid.LexBIG.Impl.LexBIGServiceImpl;import org.LexGrid.LexBIG.LexBIGService.LexBIGService;import org.LexGrid.LexBIG.LexBIGService.LexBIGServiceManager;import org.LexGrid.annotations.LgAdminFunction;import org.apache.commons.cli.BasicParser;import org.apache.commons.cli.CommandLine;import org.apache.commons.cli.Option;import org.apache.commons.cli.Options;import org.apache.commons.cli.ParseException;import org.lexevs.system.ResourceManager;import edu.mayo.informatics.resourcereader.core.StringUtils;@SuppressWarnings("deprecation")@LgAdminFunctionpublic class LoadMedDRA {    public static void main(String[] args) {        try {            new LoadMedDRA().run(args);        } catch (LBResourceUnavailableException e) {            Util.displayTaggedMessage(e.getMessage());        } catch (Exception e) {            Util.displayAndLogError("REQUEST FAILED !!!", e);        }    }    public LoadMedDRA() {        super();    }    /**     * Primary entry point for the program.     *      * @throws Exception     */    public void run(String[] args) throws Exception {        synchronized (ResourceManager.instance()) {            // Parse the command line ...            CommandLine cl = null;            Options options = getCommandOptions();            int vl = -1;            try {                cl = new BasicParser().parse(options, args);                if (cl.hasOption("v"))                    vl = Integer.parseInt(cl.getOptionValue("v"));            } catch (ParseException e) {                Util                        .displayCommandOptions(                                "LoadMedDRA",                                options,                                "\n LoadMedDRA -in \"file:///path/\" -a"                                        + "\n LoadMedDRA -in \"file:///path/\"  -mf \"file:///path/to/myCodingScheme-manifest.xml\" -a"                                        + "\n LoadMedDRA -in \"file:///path/\" -cui \"file:///path/to/MRCONSO\""                                        + "\n LoadMedDRA -in \"file:///path/\" -v 0" + Util.getURIHelp(), e);                return;            }            // Interpret provided values ...            String manUriStr = cl.getOptionValue("mf");            URI manifest = null;                        if (!StringUtils.isNull(manUriStr))                manifest = Util.string2FileURI(manUriStr);                        URI source = Util.string2FileURI(cl.getOptionValue("in"));            boolean activate = vl < 0 && cl.hasOption("a");                        URI cui = Util.string2FileURI(cl.getOptionValue("cui"));                                    if (vl >= 0) {                Util.displayTaggedMessage("VALIDATING SOURCE URI: " + source.toString());            } else {                Util.displayTaggedMessage("LOADING FROM URI: " + source.toString());                Util.displayTaggedMessage(activate ? "ACTIVATE ON SUCCESS" : "NO ACTIVATION");            }            // Find the registered extension handling this type of load ...            LexBIGService lbs = LexBIGServiceImpl.defaultInstance();            LexBIGServiceManager lbsm = lbs.getServiceManager(null);            MedDRA_Loader loader = (MedDRA_Loader) lbsm.getLoader(org.LexGrid.LexBIG.Impl.loaders.MedDRALoaderImpl.name);            // Perform the requested load or validate action ...            // TODO: Unclear what I need here            if (vl >= 0) {                loader.validate(source, vl);                Util.displayTaggedMessage("VALIDATION SUCCESSFUL");            } else {                loader.setCodingSchemeManifestURI(manifest);                loader.load(source, cui,false, true);                Util.displayLoaderStatus(loader);            }            // If specified, set the associated tag on the newly loaded            // scheme(s) ...            if (vl < 0 && cl.hasOption("t")) {                String tag = cl.getOptionValue("t");                AbsoluteCodingSchemeVersionReference[] refs = loader.getCodingSchemeReferences();                for (int i = 0; i < refs.length; i++) {                    AbsoluteCodingSchemeVersionReference ref = refs[i];                    lbsm.setVersionTag(ref, tag);                    Util.displayTaggedMessage("Tag assigned>> " + ref.getCodingSchemeURN() + " Version>> "                            + ref.getCodingSchemeVersion());                }            }            // If requested, activate the newly loaded scheme(s) ...            if (activate) {                AbsoluteCodingSchemeVersionReference[] refs = loader.getCodingSchemeReferences();                for (int i = 0; i < refs.length; i++) {                    AbsoluteCodingSchemeVersionReference ref = refs[i];                    lbsm.activateCodingSchemeVersion(ref);                    Util.displayTaggedMessage("Scheme activated>> " + ref.getCodingSchemeURN() + " Version>> "                            + ref.getCodingSchemeVersion());                }            }        }    }    /**     * Return supported command options.     *      * @return org.apache.commons.cli.Options     */    private Options getCommandOptions() {        Options options = new Options();        Option o;        o = new Option("in", "input", true, "URI or path specifying location of the source files.");        o.setArgName("uri");        o.setRequired(true);        options.addOption(o);                o = new Option("cui", "umlscui", true, "URI or path specifying location of the cui source file.");        o.setArgName("uri");        o.setRequired(false);        options.addOption(o);        o = new Option("mf", "manifest", true, "URI or path specifying location of the manifest file.");        o.setArgName("uri");        o.setRequired(false);        options.addOption(o);        o = new Option("v", "validate", true, "Validation only; no load. If specified, 'a' and 't' "                + "are ignored. 0 to verify the file conforms to the OBO format.");        o.setArgName("int");        o.setRequired(false);        options.addOption(o);        o = new Option("a", "activate", false, "ActivateScheme on successful load; if unspecified the "                + "vocabulary is loaded but not activated.");        o.setRequired(false);        options.addOption(o);        o = new Option("t", "tag", true, "An optional tag ID (e.g. 'PRODUCTION' or 'TEST') to assign.");        o.setArgName("id");        o.setRequired(false);        options.addOption(o);        return options;    }}