package edu.mayo.informatics.lexgrid.convert.directConversions.medDRA;import java.io.FileNotFoundException;import java.io.FileReader;import java.lang.reflect.Field;import java.net.URI;import java.util.Arrays;import java.util.Hashtable;import java.util.List;import org.LexGrid.LexBIG.Utility.logging.LgMessageDirectorIF;import org.LexGrid.codingSchemes.CodingScheme;import org.LexGrid.commonTypes.EntityDescription;import org.LexGrid.commonTypes.Property;import org.LexGrid.commonTypes.Text;import org.LexGrid.commonTypes.types.EntityTypes;import org.LexGrid.concepts.Comment;import org.LexGrid.concepts.Definition;import org.LexGrid.concepts.Entities;import org.LexGrid.concepts.Entity;import org.LexGrid.concepts.Presentation;import org.LexGrid.custom.relations.RelationsUtil;import org.LexGrid.naming.Mappings;import org.LexGrid.naming.SupportedCodingScheme;import org.LexGrid.naming.SupportedContainerName;import org.LexGrid.naming.SupportedHierarchy;import org.LexGrid.naming.SupportedLanguage;import org.LexGrid.naming.SupportedProperty;import org.LexGrid.relations.AssociationPredicate;import org.LexGrid.relations.AssociationSource;import org.LexGrid.relations.AssociationTarget;import org.LexGrid.relations.Relations;import org.lexevs.logging.messaging.impl.CachingMessageDirectorImpl;import au.com.bytecode.opencsv.CSVReader;import au.com.bytecode.opencsv.bean.ColumnPositionMappingStrategy;import au.com.bytecode.opencsv.bean.CsvToBean;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.Data.Database;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.Data.DatabaseEntityRecord;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.Data.DatabaseMapRecord;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.Data.DatabaseRecord;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.Data.MedDRARecord_Utils;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.Data.MedDRARecord_intl_ord;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.Data.MedDRARecord_meddra_release;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.Data.MedDRARecord_smq_content;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.Data.MedDRARecord_soc;import edu.mayo.informatics.lexgrid.convert.directConversions.medDRA.Data.MedDRA_Metadata;public class MedDRAMapToLexGrid {    private static MedDRA_Metadata [] meddraMetaData = MedDRA_Metadata.values();    private LgMessageDirectorIF messages_;    private URI medDRASourceDir;    private Database meddraDatabase;    private Hashtable<String, Entity> idToEntityHash;            public MedDRAMapToLexGrid(URI inFileName, LgMessageDirectorIF lg_messages) {        this.messages_ = new CachingMessageDirectorImpl(lg_messages);        this.medDRASourceDir = inFileName;        meddraDatabase = new Database();        idToEntityHash = new Hashtable<String, Entity>();    }    /// ================    /// Load Data Files    /// ================    public void readMedDRAFiles() {        String input;                for(int i=0; i < meddraMetaData.length; i++){            input = medDRASourceDir.getPath() + meddraMetaData[i].filename();            try {                              FileReader fileReader = new FileReader(input);                CSVReader reader = new CSVReader(fileReader, '$');                ColumnPositionMappingStrategy<DatabaseRecord> strat = new ColumnPositionMappingStrategy<DatabaseRecord>();                strat.setType(meddraMetaData[i].classname());                String[] columns = getFields(meddraMetaData[i].classname());                             strat.setColumnMapping(columns);                    CsvToBean<DatabaseRecord> csv = new CsvToBean<DatabaseRecord>();                List<DatabaseRecord> list = csv.parse(strat, reader);                meddraDatabase.add(meddraMetaData[i].tablename(), list);            } catch (FileNotFoundException e) {                messages_.error("MedDRA input file missing.", e);            } catch (Exception e) {                messages_.error("Failed to read MedDRA files.");            }        }    }        public boolean validateMedDRABeans() throws IllegalArgumentException, SecurityException, IllegalAccessException, NoSuchFieldException {        messages_.info("Checking validity of data imported.");        for(int i=0; i < meddraMetaData.length; i++){            String tablename = meddraMetaData[i].tablename();            List<DatabaseRecord> records = meddraDatabase.get(tablename);            int row = 0;            for(DatabaseRecord record : records){                if(!record.fieldsValid()){                    String fieldValues = record.toString();                    messages_.error("ERROR in data imported from file (row " + row + "): " + meddraMetaData[i].filename());                    messages_.error(fieldValues);                    return false;                }                row++;            }        }                        messages_.info("Data imported passed validity check.");                return true;    }        private String[] getFields(Class<?> class1) {        Field [] fields = class1.getDeclaredFields();           String [] fieldnames = new String[fields.length - 1];                for(int i=1; i < fields.length; i++){            fieldnames[i-1] = fields[i].getName();        }        return fieldnames;    }    /// =========    /// Map Data    /// =========    public void mapToLexGrid(CodingScheme csclass) {        try {            loadCodingScheme(csclass);            loadConcepts(csclass);            loadRelations(csclass);        } catch (Exception e) {            messages_.error("Failed to map MedDRA data to LexEVS.");        }                     messages_.info("Mapping completed, returning to loader");    }    /// =================    /// Load CodingScheme    /// =================    private void loadCodingScheme(CodingScheme csclass) {        try {            messages_.info("Loading coding scheme information");                        // Set Coding Scheme Info            csclass.setCodingSchemeName(MedDRA2LGConstants.DEFAULT_NAME);            csclass.setFormalName(MedDRA2LGConstants.DEFAULT_FORMAL_NAME);            csclass.setCodingSchemeURI(MedDRA2LGConstants.DEFAULT_URN);            csclass.setDefaultLanguage(MedDRA2LGConstants.DEFAULT_LANG);            csclass.setRepresentsVersion(this.getVersion());            csclass.getLocalNameAsReference().add(MedDRA2LGConstants.DEFAULT_NAME);                        EntityDescription enDesc = new EntityDescription();            enDesc.setContent(MedDRA2LGConstants.DEFAULT_ENTITY_DESCRIPTION);            csclass.setEntityDescription(enDesc);                        Text txt = new Text();            txt.setContent(MedDRA2LGConstants.DEFAULT_COPYRIGHT);            csclass.setCopyright(txt);                        // Set Coding Scheme Mappings            csclass.setMappings(new Mappings());            SupportedCodingScheme scs = new SupportedCodingScheme();            scs.setLocalId(csclass.getCodingSchemeName());            scs.setUri(csclass.getCodingSchemeURI());            csclass.getMappings().addSupportedCodingScheme(scs);                        // And Language            SupportedLanguage lang = new SupportedLanguage();            lang.setLocalId(csclass.getDefaultLanguage());            csclass.getMappings().addSupportedLanguage(lang);                        // Add Supported Properties            String [] supportedNames = {"P-1", "P-2", "T-1", "T-2", "PRIMARY_SOC", "SMQ_Code",                    "term_level", "term_scope", "term_category",                     "term_weight", "term_status", "term_addition_version",                     "term_last_modified_version", "Name", "Code", "Level", "Description",                     "Source", "Note", "MedDRA Dictionary Version", "Status", "Algorithm"};                        for(int i=0; i < supportedNames.length; i++){                SupportedProperty property = new SupportedProperty();                property.setLocalId(supportedNames[i]);                csclass.getMappings().addSupportedProperty(property);            }                                    // Collect some global values            String subtype = MedDRA2LGConstants.ASSOCIATION_HAS_SUBTYPE;            String isa = MedDRA2LGConstants.ASSOCIATION_IS_A;            String root = MedDRA2LGConstants.DEFAULT_ROOT_NODE;            String relationsName = MedDRA2LGConstants.CONTAINER_NAME_RELATIONS;                        // Set Supported Hierarchies            SupportedHierarchy hierarchy = this.createSupportedHierarchy(isa, subtype, root, true);            csclass.getMappings().addSupportedHierarchy(hierarchy);                                   // Setup Container for relations            SupportedContainerName scn= new SupportedContainerName();            scn.setLocalId(relationsName);            csclass.getMappings().addSupportedContainerName(scn);                        // Add relation to codingScheme with an AssociationPredicate            Relations relations = new Relations();            relations.setContainerName(relationsName);            AssociationPredicate predicate = new AssociationPredicate();            predicate.setAssociationName(subtype);            relations.addAssociationPredicate(predicate);                        csclass.addRelations(relations);                    } catch (Exception e) {            messages_.error("Failed while preparing MedDRA Coding Scheme Class");        }     }           private SupportedHierarchy createSupportedHierarchy(String type, String associationName, String rootNode, boolean forwardNavigable){       SupportedHierarchy hierarchy = new SupportedHierarchy();       hierarchy.setLocalId(type);       hierarchy.setAssociationNames(Arrays.asList(associationName));              hierarchy.setRootCode(rootNode);       hierarchy.setIsForwardNavigable(forwardNavigable);              return hierarchy;    }    private String getVersion() {       String version = "UNKNOWN";       List<DatabaseRecord> records = meddraDatabase.get(MedDRA_Metadata.RELEASE.tablename());       if(records.size() >= 1){           version = ((MedDRARecord_meddra_release) records.get(0)).getVersion();       }       return version;    }    /// ==============    /// Load Concepts    /// ==============    private void loadConcepts(CodingScheme csclass) {        messages_.info("Loading concepts");        try{            String entityCodeNamespace = csclass.getCodingSchemeName();                        Entities concepts = this.getEntitiesInCodingScheme(csclass);                        this.storeRootEntity(csclass.getCodingSchemeName());            this.storeTopNodeEntity(MedDRA2LGConstants.TOP_NODE_SOC, csclass.getCodingSchemeName(), concepts);            this.storeTopNodeEntity(MedDRA2LGConstants.TOP_NODE_SMQ, csclass.getCodingSchemeName(), concepts);                                List<String> tablenames = MedDRA_Metadata.getEntityTables();            for(String table : tablenames){                messages_.info("Loading: " + table);                this.loadConceptsTable(table, entityCodeNamespace, csclass);                    }        } catch (Exception e) {            messages_.error("Failed while preparing MedDRA Concepts");        }     }        private void storeRootEntity(String codingSchemeName) {        String rootCode = MedDRA2LGConstants.DEFAULT_ROOT_NODE;        String rootName = MedDRA2LGConstants.DEFAULT_ROOT_NODE;                Entity rootEntity = this.createEntity(rootCode, rootName, codingSchemeName);        idToEntityHash.put(rootCode, rootEntity);    }    private Entities getEntitiesInCodingScheme(CodingScheme csclass) {        Entities concepts = csclass.getEntities();        if (concepts == null) {            concepts = new Entities();            csclass.setEntities(concepts);        }                return concepts;    }    private void storeTopNodeEntity(String category, String codingSchemeName, Entities entities){        Entity newEntity = this.createEntity(category, category, codingSchemeName);                  Presentation presentation = MedDRARecord_Utils.createPresentation(category, category, "TOP NODE", true);        newEntity.addPresentation(presentation);        idToEntityHash.put(category, newEntity);        entities.addEntity(newEntity);    }        private void loadConceptsTable(String table, String entityCodeNamespace, CodingScheme csclass) {        List<DatabaseRecord> records = meddraDatabase.get(table);        Entities entities = csclass.getEntities();        boolean duplicateID = false;                for(DatabaseRecord record : records){            DatabaseEntityRecord meddraRecord = (DatabaseEntityRecord) record;            duplicateID = false;                        if(table.equals(MedDRA_Metadata.LOW_LEVEL_TERMS.tablename())){                duplicateID = this.loadLLT(meddraRecord);            }                        if(!duplicateID){                Entity newEntity = this.createEntity(meddraRecord.getCode(), meddraRecord.getName(), csclass.getCodingSchemeName());                                 if(table.equals(MedDRA_Metadata.SYSTEM_ORGAN_CLASSES.tablename())){                    this.loadIntlOrder(meddraRecord);                }                                this.loadEntityProperties(meddraRecord, newEntity);                this.storeEntity(newEntity, entities);            }        }            }        private void loadEntityProperties(DatabaseEntityRecord meddraRecord, Entity newEntity) {        List<Presentation> presentations = meddraRecord.getPresentations();        List<Definition> definitions = meddraRecord.getDefinitions();        List<Comment> comments = meddraRecord.getComments();        List<Property> properties = meddraRecord.getProperties();                newEntity.setPresentation(presentations);        newEntity.setDefinition(definitions);        newEntity.setComment(comments);        newEntity.setProperty(properties);    }    private boolean loadLLT(DatabaseEntityRecord meddraRecord) {        Entity entityLoaded = idToEntityHash.get(meddraRecord.getCode());                if(entityLoaded != null){            Presentation presentation = MedDRARecord_Utils.createPresentation("T-2", meddraRecord.getName(), "LT", false);             entityLoaded.addPresentation(presentation);            return true;        }                return false;    }    private void storeEntity(Entity newEntity, Entities entities) {        idToEntityHash.put(newEntity.getEntityCode(), newEntity);        entities.addEntity(newEntity);    }    private Entity createEntity(String code, String name, String codeNamespace) {        Entity newEntity = new Entity();        newEntity.setEntityCode(code);        EntityDescription entityDescription = new EntityDescription();        entityDescription.setContent(name);                newEntity.setEntityDescription(entityDescription );        newEntity.setEntityType(new String[] { EntityTypes.CONCEPT.toString() });        newEntity.setEntityCodeNamespace(codeNamespace);        newEntity.setIsActive(true);                return newEntity;    }    private void loadIntlOrder(DatabaseEntityRecord meddraRecord) {        String intlOrder = "-1";        List<DatabaseRecord> intlOrders = meddraDatabase.get(MedDRA_Metadata.SOC_INTL_MAP.tablename());        for(DatabaseRecord order : intlOrders){            if(((MedDRARecord_intl_ord) order).getSoc_code().equals(meddraRecord.getCode())){                intlOrder = ((MedDRARecord_intl_ord) order).getIntl_ord_code();            }        }        ((MedDRARecord_soc) meddraRecord).setIntlOrder(intlOrder);    }        /// ==============    /// Load Relations    /// ==============    private void loadRelations(CodingScheme csclass) {        messages_.info("Loading all relations properties");        try{            this.storeRelation(MedDRA2LGConstants.DEFAULT_ROOT_NODE, MedDRA2LGConstants.TOP_NODE_SMQ, csclass);            this.storeRelation(MedDRA2LGConstants.DEFAULT_ROOT_NODE, MedDRA2LGConstants.TOP_NODE_SOC, csclass);                        List<String> tablenames = MedDRA_Metadata.getMapTables();            for(String table : tablenames){                messages_.info("Loading: " + table);                this.loadRelationsTable(table, csclass);                    }          } catch (Exception e) {            messages_.error("Failed while preparing MedDRA Relations");        }     }    private void loadRelationsTable(String table, CodingScheme csclass) {        String source, target;                  List<DatabaseRecord> records = meddraDatabase.get(table);        boolean loadingSMQ = (table.equals(MedDRA_Metadata.SMQ_CONTENT.tablename()) ? true : false);                for(DatabaseRecord record : records){            DatabaseMapRecord meddraRecord = (DatabaseMapRecord) record;            source = meddraRecord.getSource();            target = meddraRecord.getTarget();            if(!source.equals(target)){                if(loadingSMQ){                    this.loadSMQInfo(record, target);                }                this.storeRelation(source, target, csclass);                            }        }    }    private void storeRelation(String source, String target, CodingScheme csclass) {        String association = MedDRA2LGConstants.ASSOCIATION_HAS_SUBTYPE;        AssociationPredicate parent_association = (AssociationPredicate) RelationsUtil                .resolveAssociationPredicates(csclass, association).get(0);        Entity sourceEntity = idToEntityHash.get(source);        Entity targetEntity = idToEntityHash.get(target);       if (sourceEntity != null && targetEntity != null) {            AssociationSource ai = new AssociationSource();            ai.setSourceEntityCode(sourceEntity.getEntityCode());            ai.setSourceEntityCodeNamespace(csclass.getCodingSchemeName());            ai = RelationsUtil.subsume(parent_association, ai);                        AssociationTarget at = new AssociationTarget();            at.setTargetEntityCode(targetEntity.getEntityCode());            at.setTargetEntityCodeNamespace(csclass.getCodingSchemeName());            at = RelationsUtil.subsume(ai, at);        }          }    private void loadSMQInfo(DatabaseRecord record, String target) {        MedDRARecord_smq_content smqRecord = (MedDRARecord_smq_content) record;        Entity targetEntity = idToEntityHash.get(target);        if(targetEntity != null){            targetEntity.addProperty(MedDRARecord_Utils.createSMQProperty("SMQ_Code", smqRecord));                                                //            targetEntity.addProperty(MedDRARecord_Utils.createProperty("SMQ:term level", smqRecord.getTerm_level()));//            targetEntity.addProperty(MedDRARecord_Utils.createProperty("SMQ:term scope", smqRecord.getTerm_scope()));//            targetEntity.addProperty(MedDRARecord_Utils.createProperty("SMQ:term category", smqRecord.getTerm_category()));//            targetEntity.addProperty(MedDRARecord_Utils.createProperty("SMQ:term weight", smqRecord.getTerm_weight()));//            targetEntity.addProperty(MedDRARecord_Utils.createProperty("SMQ:term status", smqRecord.getTerm_status()));//            targetEntity.addProperty(MedDRARecord_Utils.createProperty("SMQ:term addition version", smqRecord.getTerm_addition_version()));//            targetEntity.addProperty(MedDRARecord_Utils.createProperty("SMQ:term last modified version", smqRecord.getTerm_last_modified_version()));        }    }}